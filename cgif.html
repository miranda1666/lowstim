<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>GIF Player Widget</title>
  <style>
    :root{
      /* subtle cream palette */
      --page:#ffffff;
      --card:#fffdf7;
      --media:#f4efe6;

      --bar:#e7ddcf;
      --barText:#3a3226;

      --btnBg:rgba(255,255,255,.65);
      --btnBorder:rgba(58,50,38,.18);
      --btnIcon:#3a3226;

      --sliderTrack:rgba(58,50,38,.16);
      --sliderThumb:#ffffff;

      --stroke:rgba(80,60,20,.08);
      --shadow:0 18px 60px rgba(40,30,10,.10);

      --radius:22px;
    }

    html,body{height:100%;}
    body{
      margin:0;
      background:var(--page);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      display:flex;
      justify-content:center;
      align-items:flex-start;
      padding:18px;
      box-sizing:border-box;
      color:var(--barText);
    }

    /* "small widget ~ 1/3 page" feel */
    .wrap{
      width:min(760px, 92vw);
    }

    .player{
      border-radius:var(--radius);
      overflow:hidden;
      background:var(--card);
      border:1px solid var(--stroke);
      box-shadow:var(--shadow);
    }

    .media{
      position:relative;
      width:100%;
      aspect-ratio:16/9;
      background:var(--media);
      overflow:hidden;
    }

    .media img, .media canvas{
      width:100%;
      height:100%;
      object-fit:cover;
      display:block;
    }
    .media canvas{ display:none; }

    .stamp{
      position:absolute;
      left:16px;
      bottom:14px;
      padding:8px 10px;
      border-radius:14px;
      background:rgba(0,0,0,.14);
      color:rgba(255,255,255,.92);
      font-weight:650;
      font-size:13px;
      line-height:1.2;
      text-shadow: 0 2px 10px rgba(0,0,0,.35);
      border:1px solid rgba(255,255,255,.18);
      backdrop-filter: blur(6px);
      user-select:none;
    }

    .bar{
      display:flex;
      align-items:center;
      gap:14px;
      padding:14px 16px;
      background:var(--bar);
      color:var(--barText);
    }

    .left{
      display:flex;
      align-items:center;
      gap:12px;
      flex:1 1 auto;
      min-width:0;
    }

    .controls{
      display:flex;
      gap:10px;
      align-items:center;
      flex:0 0 auto;
    }

    .btn{
      width:40px;
      height:40px;
      border-radius:999px;
      border:1.5px solid var(--btnBorder);
      background:var(--btnBg);
      display:flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
      user-select:none;
      transition: transform .06s ease, filter .15s ease;
    }
    .btn:hover{ filter:brightness(.99); }
    .btn:active{ transform: translateY(1px); }

    .btn svg{
      width:18px;
      height:18px;
      fill:var(--btnIcon);
    }

    .title{
      font-weight:700;
      font-size:15px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      min-width:0;
    }

    .right{
      flex:0 0 auto;
      display:flex;
      align-items:center;
      gap:10px;
    }

    input[type="range"]{
      width:280px;
      max-width:34vw;
      height:10px;
      -webkit-appearance:none;
      appearance:none;
      background:var(--sliderTrack);
      border-radius:999px;
      outline:none;
      cursor:pointer;
    }
    input[type="range"]::-webkit-slider-thumb{
      -webkit-appearance:none;
      appearance:none;
      width:18px;
      height:18px;
      border-radius:6px;
      background:var(--sliderThumb);
      border:1px solid rgba(58,50,38,.12);
      box-shadow: 0 4px 14px rgba(0,0,0,.10);
    }
    input[type="range"]::-moz-range-thumb{
      width:18px;
      height:18px;
      border-radius:6px;
      background:var(--sliderThumb);
      border:1px solid rgba(58,50,38,.12);
      box-shadow: 0 4px 14px rgba(0,0,0,.10);
    }

    details{
      border-top:1px solid rgba(80,60,20,.08);
      background:rgba(80,60,20,.02);
      padding:10px 14px 14px;
    }
    summary{
      cursor:pointer;
      user-select:none;
      list-style:none;
      display:flex;
      align-items:center;
      justify-content:space-between;
      font-weight:800;
      font-size:13px;
      color:rgba(58,50,38,.76);
    }
    summary::-webkit-details-marker{ display:none; }

    .panel{
      margin-top:12px;
      display:grid;
      gap:12px;
    }

    .badges{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      font-size:12px;
      color:rgba(58,50,38,.62);
      font-weight:700;
    }
    .badge{
      padding:6px 10px;
      border-radius:999px;
      background:rgba(58,50,38,.06);
      border:1px solid rgba(58,50,38,.08);
    }

    .grid{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap:10px;
    }
    @media (max-width:720px){ .grid{ grid-template-columns:1fr 1fr; } }
    @media (max-width:420px){ .grid{ grid-template-columns:1fr; } }

    label{
      font-size:12px;
      font-weight:800;
      color:rgba(58,50,38,.72);
      display:block;
      margin-bottom:6px;
    }

    input[type="text"], input[type="number"], textarea{
      width:100%;
      box-sizing:border-box;
      border-radius:12px;
      border:1px solid rgba(58,50,38,.16);
      background:#fff;
      padding:10px 10px;
      font-size:13px;
      outline:none;
      color:rgba(58,50,38,.92);
    }

    input[type="color"]{
      width:100%;
      height:38px;
      padding:4px;
      border-radius:12px;
      border:1px solid rgba(58,50,38,.16);
      background:#fff;
      cursor:pointer;
    }

    textarea{ min-height: 92px; resize: vertical; }

    .row{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
    }

    .miniBtn{
      border-radius:12px;
      border:1px solid rgba(58,50,38,.16);
      background:#fff;
      padding:10px 12px;
      cursor:pointer;
      font-weight:900;
      font-size:13px;
      color:rgba(58,50,38,.92);
    }
    .miniBtn:active{ transform: translateY(1px); }

    .hint{
      font-size:12px;
      color:rgba(58,50,38,.60);
      line-height:1.35;
    }

    .hidden{ display:none !important; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="player">

      <div class="media">
        <img id="gifImg" alt="GIF" />
        <canvas id="freezeCanvas"></canvas>

        <div class="stamp">
          <div id="stampDate"></div>
          <div id="stampTime"></div>
        </div>
      </div>

      <div class="bar">
        <div class="left">
          <div class="controls">
            <button class="btn" id="shuffleBtn" title="Shuffle">
              <svg viewBox="0 0 24 24"><path d="M17 3h4v4h-2V6.41l-4.29 4.3-1.42-1.42L17.59 5H17V3zM3 7h4.59l3 3-1.42 1.42L6.76 9H3V7zm0 10h3.76l2.41-2.41 1.42 1.42-3 2.99H3v-2zm18-2v4h-4v-2h.59l-4.88-4.88 1.42-1.42L18.59 17H19v-2h2z"/></svg>
            </button>

            <button class="btn" id="prevBtn" title="Previous">
              <svg viewBox="0 0 24 24"><path d="M6 6h2v12H6V6zm3.5 6 10 6V6l-10 6z"/></svg>
            </button>

            <button class="btn" id="playBtn" title="Play/Pause">
              <svg id="pauseIcon" viewBox="0 0 24 24"><path d="M6 5h4v14H6V5zm8 0h4v14h-4V5z"/></svg>
              <svg id="playIcon" class="hidden" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
            </button>

            <button class="btn" id="nextBtn" title="Next">
              <svg viewBox="0 0 24 24"><path d="M16 6h2v12h-2V6zM5 18l10-6L5 6v12z"/></svg>
            </button>
          </div>

          <div class="title" id="trackTitle">GIF Player</div>
        </div>

        <div class="right">
          <input id="progress" type="range" min="0" max="1000" value="0" />
        </div>
      </div>

      <details>
        <summary>
          <span>Customize</span>
          <span class="hint">colors • gifs • upload</span>
        </summary>

        <div class="panel">
          <div class="badges">
            <span class="badge" id="countBadge">1 / 1</span>
            <span class="badge" id="modeBadge">Playing</span>
          </div>

          <div class="grid">
            <div>
              <label>Page background</label>
              <input type="color" id="cPage" value="#ffffff" />
            </div>
            <div>
              <label>Card background</label>
              <input type="color" id="cCard" value="#fffdf7" />
            </div>
            <div>
              <label>Media background</label>
              <input type="color" id="cMedia" value="#f4efe6" />
            </div>

            <div>
              <label>Bar</label>
              <input type="color" id="cBar" value="#e7ddcf" />
            </div>
            <div>
              <label>Bar text</label>
              <input type="color" id="cBarText" value="#3a3226" />
            </div>
            <div>
              <label>Buttons (icon)</label>
              <input type="color" id="cBtnIcon" value="#3a3226" />
            </div>

            <div>
              <label>Buttons (background)</label>
              <input type="color" id="cBtnBg" value="#ffffff" />
            </div>
            <div>
              <label>Buttons (border)</label>
              <input type="color" id="cBtnBorder" value="#d7cdbc" />
            </div>
            <div>
              <label>Slider track</label>
              <input type="color" id="cSliderTrack" value="#d8cfbf" />
            </div>

            <div>
              <label>Slider thumb</label>
              <input type="color" id="cSliderThumb" value="#ffffff"'
            />
            </div>
            <div>
              <label>Auto-advance (seconds)</label>
              <input type="number" id="intervalSec" min="2" max="300" step="1" value="12" />
            </div>
          </div>

          <div class="grid">
            <div style="grid-column: span 2;">
              <label>Add GIF by URL</label>
              <input type="text" id="gifUrlInput" placeholder="https://.../file.gif" />
              <div class="row" style="margin-top:8px;">
                <button class="miniBtn" id="addGifUrlBtn" type="button">Add URL</button>
                <button class="miniBtn" id="removeCurrentBtn" type="button">Remove current</button>
              </div>
              <div class="hint">URLs can still be blocked by some hosts. Upload is the most reliable.</div>
            </div>

            <div>
              <label>Upload GIF file</label>
              <input type="file" id="gifFileInput" accept="image/gif" />
              <div class="row" style="margin-top:8px;">
                <button class="miniBtn" id="addGifFileBtn" type="button">Add file</button>
              </div>
              <div class="hint">Stored locally in your browser (per user). Not shared with others.</div>
            </div>
          </div>

          <div>
            <label>GIF list (one per line)</label>
            <textarea id="gifListBox" spellcheck="false"></textarea>
            <div class="row" style="margin-top:8px;">
              <button class="miniBtn" id="applyListBtn" type="button">Apply list</button>
              <button class="miniBtn" id="clearUploadsBtn" type="button">Clear uploaded files</button>
            </div>
            <div class="hint">This widget is isolated per GitHub Pages path + per browser profile.</div>
          </div>
        </div>
      </details>

    </div>
  </div>

<script>
  /**
   * ✅ BEST RELIABILITY: ship default.gif with your GitHub Pages repo.
   * Put the file next to index.html as "default.gif".
   */
  const DEFAULT_GIF_PATH = "./default.gif"; // <-- put your uploaded GIF here in the repo
  const DEFAULT_TITLE = "GIF Player";

  // Per-embed isolation (each GitHub Pages path has its own state)
  const STORAGE_KEY = "gif_player_widget_v8:" + location.pathname;

  // IndexedDB for uploaded blobs (per-user, per-browser)
  const DB_NAME = "gif_player_uploads_v1";
  const DB_STORE = "gifs";

  function openDB(){
    return new Promise((resolve, reject) => {
      const req = indexedDB.open(DB_NAME, 1);
      req.onupgradeneeded = () => {
        const db = req.result;
        if (!db.objectStoreNames.contains(DB_STORE)) {
          db.createObjectStore(DB_STORE, { keyPath: "id" });
        }
      };
      req.onsuccess = () => resolve(req.result);
      req.onerror = () => reject(req.error);
    });
  }

  async function dbPut(record){
    const db = await openDB();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(DB_STORE, "readwrite");
      tx.objectStore(DB_STORE).put(record);
      tx.oncomplete = () => resolve(true);
      tx.onerror = () => reject(tx.error);
    });
  }

  async function dbGet(id){
    const db = await openDB();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(DB_STORE, "readonly");
      const req = tx.objectStore(DB_STORE).get(id);
      req.onsuccess = () => resolve(req.result || null);
      req.onerror = () => reject(req.error);
    });
  }

  async function dbClear(){
    const db = await openDB();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(DB_STORE, "readwrite");
      tx.objectStore(DB_STORE).clear();
      tx.oncomplete = () => resolve(true);
      tx.onerror = () => reject(tx.error);
    });
  }

  function $(s){ return document.querySelector(s); }
  const clamp = (n,a,b) => Math.max(a, Math.min(b,n));

  let state = {
    gifs: [
      { title: DEFAULT_TITLE, type: "path", value: DEFAULT_GIF_PATH } // path in repo
    ],
    index: 0,
    playing: true,
    shuffle: false,
    intervalSec: 12,
    colors: {
      page:"#ffffff",
      card:"#fffdf7",
      media:"#f4efe6",
      bar:"#e7ddcf",
      barText:"#3a3226",
      btnBg:"#ffffff",
      btnBorder:"#d7cdbc",
      btnIcon:"#3a3226",
      sliderTrack:"#d8cfbf",
      sliderThumb:"#ffffff"
    }
  };

  // restore
  try{
    const raw = localStorage.getItem(STORAGE_KEY);
    if(raw){
      const saved = JSON.parse(raw);
      if(saved && typeof saved === "object"){
        state = {
          ...state,
          ...saved,
          colors: { ...state.colors, ...(saved.colors || {}) }
        };
      }
    }
  }catch(_){}

  function save(){
    try{ localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); }catch(_){}
  }

  // UI
  const gifImg = $("#gifImg");
  const canvas = $("#freezeCanvas");
  const ctx = canvas.getContext("2d");

  const playIcon = $("#playIcon");
  const pauseIcon = $("#pauseIcon");

  const countBadge = $("#countBadge");
  const modeBadge = $("#modeBadge");
  const titleEl = $("#trackTitle");

  const progress = $("#progress");

  // color inputs
  const cPage = $("#cPage");
  const cCard = $("#cCard");
  const cMedia = $("#cMedia");
  const cBar = $("#cBar");
  const cBarText = $("#cBarText");
  const cBtnBg = $("#cBtnBg");
  const cBtnBorder = $("#cBtnBorder");
  const cBtnIcon = $("#cBtnIcon");
  const cSliderTrack = $("#cSliderTrack");
  const cSliderThumb = $("#cSliderThumb");
  const intervalSec = $("#intervalSec");

  const gifUrlInput = $("#gifUrlInput");
  const addGifUrlBtn = $("#addGifUrlBtn");
  const gifFileInput = $("#gifFileInput");
  const addGifFileBtn = $("#addGifFileBtn");
  const removeCurrentBtn = $("#removeCurrentBtn");
  const gifListBox = $("#gifListBox");
  const applyListBtn = $("#applyListBtn");
  const clearUploadsBtn = $("#clearUploadsBtn");

  function applyColors(){
    document.documentElement.style.setProperty("--page", state.colors.page);
    document.documentElement.style.setProperty("--card", state.colors.card);
    document.documentElement.style.setProperty("--media", state.colors.media);
    document.documentElement.style.setProperty("--bar", state.colors.bar);
    document.documentElement.style.setProperty("--barText", state.colors.barText);

    // Convert solid hex into rgba-ish for btnBg if needed (we just use it directly)
    document.documentElement.style.setProperty("--btnBg", state.colors.btnBg);
    document.documentElement.style.setProperty("--btnBorder", state.colors.btnBorder);
    document.documentElement.style.setProperty("--btnIcon", state.colors.btnIcon);

    document.documentElement.style.setProperty("--sliderTrack", state.colors.sliderTrack);
    document.documentElement.style.setProperty("--sliderThumb", state.colors.sliderThumb);

    cPage.value = state.colors.page;
    cCard.value = state.colors.card;
    cMedia.value = state.colors.media;
    cBar.value = state.colors.bar;
    cBarText.value = state.colors.barText;
    cBtnBg.value = state.colors.btnBg;
    cBtnBorder.value = state.colors.btnBorder;
    cBtnIcon.value = state.colors.btnIcon;
    cSliderTrack.value = state.colors.sliderTrack;
    cSliderThumb.value = state.colors.sliderThumb;

    intervalSec.value = String(state.intervalSec);
  }

  function setPlayUI(){
    if(state.playing){
      playIcon.classList.add("hidden");
      pauseIcon.classList.remove("hidden");
      modeBadge.textContent = "Playing";
    }else{
      pauseIcon.classList.add("hidden");
      playIcon.classList.remove("hidden");
      modeBadge.textContent = "Paused";
    }
  }

  function updateBadges(){
    const total = state.gifs.length;
    const idx = total ? (state.index + 1) : 0;
    countBadge.textContent = `${idx} / ${total}`;
  }

  function unfreeze(){
    canvas.style.display = "none";
    gifImg.style.display = "block";
  }

  function freezeIfPossible(){
    const w = gifImg.naturalWidth || 0;
    const h = gifImg.naturalHeight || 0;
    if(!w || !h) return false;

    const rect = gifImg.getBoundingClientRect();
    canvas.width = Math.max(1, Math.round(rect.width));
    canvas.height = Math.max(1, Math.round(rect.height));
    try{
      ctx.drawImage(gifImg, 0, 0, canvas.width, canvas.height);
    }catch(_){
      return false;
    }
    gifImg.style.display = "none";
    canvas.style.display = "block";
    return true;
  }

  function cacheBust(url){
    const u = String(url);
    const sep = u.includes("?") ? "&" : "?";
    return u + sep + "v=" + Date.now().toString(36);
  }

  let objectURLs = new Map(); // id -> objectURL (for uploaded blobs), in-memory

  async function resolveSrc(item){
    if(item.type === "path"){
      return item.value; // same-origin file in repo
    }
    if(item.type === "url"){
      return item.value;
    }
    if(item.type === "upload"){
      // load from IndexedDB, create object URL
      if(objectURLs.has(item.value)) return objectURLs.get(item.value);
      const rec = await dbGet(item.value);
      if(!rec || !rec.blob) return ""; // missing
      const obj = URL.createObjectURL(rec.blob);
      objectURLs.set(item.value, obj);
      return obj;
    }
    return "";
  }

  async function showCurrent({restart=true} = {}){
    if(!state.gifs.length){
      titleEl.textContent = "No GIFs";
      gifImg.removeAttribute("src");
      gifListBox.value = "";
      updateBadges();
      save();
      return;
    }

    state.index = clamp(state.index, 0, state.gifs.length - 1);
    const cur = state.gifs[state.index];

    titleEl.textContent = cur.title || DEFAULT_TITLE;
    unfreeze();

    let src = await resolveSrc(cur);
    if(!src){
      // fallback to default path if something went missing
      src = DEFAULT_GIF_PATH;
    }

    // Always re-assign src with cachebust so it visibly animates/restarts in embeds
    gifImg.src = restart ? cacheBust(src) : src;

    // keep textarea in sync
    gifListBox.value = state.gifs.map(g => {
      if(g.type === "upload") return `upload:${g.value}`; // stable reference
      return g.value;
    }).join("\n");

    updateBadges();
    setPlayUI();
    save();
  }

  function nextIndex(){
    const total = state.gifs.length;
    if(total <= 1) return state.index;
    if(state.shuffle){
      let n = state.index;
      for(let t=0;t<12 && n===state.index;t++){
        n = Math.floor(Math.random()*total);
      }
      return n === state.index ? (state.index+1)%total : n;
    }
    return (state.index + 1) % total;
  }

  function prevIndex(){
    const total = state.gifs.length;
    if(total <= 1) return state.index;
    if(state.shuffle){
      let n = state.index;
      for(let t=0;t<12 && n===state.index;t++){
        n = Math.floor(Math.random()*total);
      }
      return n === state.index ? (state.index-1+total)%total : n;
    }
    return (state.index - 1 + total) % total;
  }

  // auto-advance / progress
  let tickTimer=null, progTimer=null, progStart=0;

  function stopTimers(){
    if(tickTimer) clearInterval(tickTimer);
    if(progTimer) clearInterval(progTimer);
    tickTimer=null; progTimer=null;
    progress.value = "0";
  }

  function startTimers(){
    stopTimers();
    if(!state.playing) return;
    const ms = state.intervalSec * 1000;
    progStart = Date.now();

    tickTimer = setInterval(() => {
      state.index = nextIndex();
      showCurrent({restart:true});
      progStart = Date.now();
    }, ms);

    progTimer = setInterval(() => {
      const ms = state.intervalSec * 1000;
      const pct = clamp((Date.now() - progStart) / ms, 0, 1);
      progress.value = String(Math.round(pct * 1000));
    }, 80);
  }

  function play(){
    state.playing = true;
    unfreeze();
    setPlayUI();
    startTimers();
    showCurrent({restart:true});
  }

  function pause(){
    state.playing = false;
    stopTimers();
    setPlayUI();
    // freeze if possible; if not, just leave playing image (still looks fine)
    freezeIfPossible();
    save();
  }

  // Events
  $("#shuffleBtn").addEventListener("click", () => {
    state.shuffle = !state.shuffle;
    $("#shuffleBtn").style.opacity = state.shuffle ? "1" : ".72";
    save();
  });

  $("#prevBtn").addEventListener("click", () => {
    state.index = prevIndex();
    showCurrent({restart:true});
    if(state.playing){ progStart = Date.now(); progress.value = "0"; }
  });

  $("#nextBtn").addEventListener("click", () => {
    state.index = nextIndex();
    showCurrent({restart:true});
    if(state.playing){ progStart = Date.now(); progress.value = "0"; }
  });

  $("#playBtn").addEventListener("click", () => {
    state.playing ? pause() : play();
  });

  progress.addEventListener("input", () => {
    if(!state.playing) return;
    const pct = clamp(parseInt(progress.value,10)/1000,0,1);
    const ms = state.intervalSec * 1000;
    progStart = Date.now() - Math.round(pct * ms);
  });

  intervalSec.addEventListener("change", () => {
    const v = clamp(parseInt(intervalSec.value || "12", 10), 2, 300);
    state.intervalSec = v;
    save();
    if(state.playing) startTimers();
  });

  // Color wiring
  function wireColor(el, key){
    el.addEventListener("input", () => {
      state.colors[key] = el.value;
      applyColors();
      save();
    });
  }
  wireColor(cPage, "page");
  wireColor(cCard, "card");
  wireColor(cMedia, "media");
  wireColor(cBar, "bar");
  wireColor(cBarText, "barText");
  wireColor(cBtnBg, "btnBg");
  wireColor(cBtnBorder, "btnBorder");
  wireColor(cBtnIcon, "btnIcon");
  wireColor(cSliderTrack, "sliderTrack");
  wireColor(cSliderThumb, "sliderThumb");

  // Add URL
  addGifUrlBtn.addEventListener("click", () => {
    const url = (gifUrlInput.value || "").trim();
    if(!url) return;
    state.gifs.push({ title: `GIF ${state.gifs.length+1}`, type:"url", value:url });
    state.index = state.gifs.length - 1;
    gifUrlInput.value = "";
    save();
    showCurrent({restart:true});
  });

  // Upload file -> store blob in IndexedDB
  addGifFileBtn.addEventListener("click", async () => {
    const file = gifFileInput.files && gifFileInput.files[0];
    if(!file) return;

    const id = "up_" + Date.now().toString(36) + "_" + Math.random().toString(36).slice(2,8);
    await dbPut({ id, blob: file, name: file.name, createdAt: Date.now() });

    state.gifs.push({ title: file.name || `Upload ${state.gifs.length+1}`, type:"upload", value:id });
    state.index = state.gifs.length - 1;
    gifFileInput.value = "";
    save();
    showCurrent({restart:true});
  });

  // Remove current
  removeCurrentBtn.addEventListener("click", () => {
    if(!state.gifs.length) return;
    const removed = state.gifs.splice(state.index, 1)[0];
    state.index = clamp(state.index, 0, Math.max(0, state.gifs.length - 1));
    save();
    showCurrent({restart:true});
  });

  // Apply list (supports:
  // - normal URLs
  // - local repo paths like ./my.gif or assets/thing.gif
  // - upload references like upload:up_abc123
  applyListBtn.addEventListener("click", () => {
    const lines = (gifListBox.value || "")
      .split("\n").map(s => s.trim()).filter(Boolean);

    if(!lines.length){
      state.gifs = [{ title: DEFAULT_TITLE, type:"path", value: DEFAULT_GIF_PATH }];
      state.index = 0;
      save();
      showCurrent({restart:true});
      return;
    }

    state.gifs = lines.map((line, i) => {
      if(line.startsWith("upload:")){
        return { title: `Upload ${i+1}`, type:"upload", value: line.slice("upload:".length) };
      }
      // treat anything that looks like http(s) as url, else as path
      const isUrl = /^https?:\/\//i.test(line);
      return { title: `GIF ${i+1}`, type: isUrl ? "url" : "path", value: line };
    });

    state.index = 0;
    save();
    showCurrent({restart:true});
  });

  // Clear uploads from IndexedDB + remove upload entries
  clearUploadsBtn.addEventListener("click", async () => {
    await dbClear();
    // revoke in-memory objectURLs
    for(const obj of objectURLs.values()){
      try{ URL.revokeObjectURL(obj); }catch(_){}
    }
    objectURLs.clear();

    state.gifs = state.gifs.filter(g => g.type !== "upload");
    if(!state.gifs.length){
      state.gifs = [{ title: DEFAULT_TITLE, type:"path", value: DEFAULT_GIF_PATH }];
    }
    state.index = 0;
    save();
    showCurrent({restart:true});
  });

  // Timestamp
  function formatStamp(d){
    const day = d.toLocaleDateString(undefined, { weekday:"long", day:"numeric", month:"long", year:"numeric" });
    const time = d.toLocaleTimeString(undefined, { hour:"2-digit", minute:"2-digit" });
    $("#stampDate").textContent = day;
    $("#stampTime").textContent = time;
  }
  formatStamp(new Date());
  setInterval(() => formatStamp(new Date()), 30*1000);

  // Init
  applyColors();
  $("#shuffleBtn").style.opacity = state.shuffle ? "1" : ".72";
  setPlayUI();
  updateBadges();
  showCurrent({restart:true});
  if(state.playing) startTimers();

</script>
</body>
</html>
