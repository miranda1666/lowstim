<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>GIF Player Widget</title>
  <style>
    :root{
      --page:#ffffff;
      --card:#fffdf7;
      --media:#f4efe6;

      --bar:#e7ddcf;
      --barText:#3a3226;

      --btnBg:rgba(255,255,255,.65);
      --btnBorder:rgba(58,50,38,.18);
      --btnIcon:#3a3226;

      --sliderTrack:rgba(58,50,38,.16);
      --sliderThumb:#ffffff;

      --stroke:rgba(80,60,20,.08);
      --shadow:0 18px 60px rgba(40,30,10,.10);

      --radius:22px;
    }

    html,body{height:100%;}
    body{
      margin:0;
      background:var(--page);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      display:flex;
      justify-content:center;
      align-items:flex-start;
      padding:18px;
      box-sizing:border-box;
      color:var(--barText);
    }

    .wrap{ width:min(760px, 92vw); }

    .player{
      border-radius:var(--radius);
      overflow:hidden;
      background:var(--card);
      border:1px solid var(--stroke);
      box-shadow:var(--shadow);
    }

    .media{
      position:relative;
      width:100%;
      aspect-ratio:16/9;
      background:var(--media);
      overflow:hidden;
    }

    .media img, .media canvas{
      width:100%;
      height:100%;
      object-fit:cover;
      display:block;
    }
    .media canvas{ display:none; }

    .stamp{
      position:absolute;
      left:16px;
      bottom:14px;
      padding:8px 10px;
      border-radius:14px;
      background:rgba(0,0,0,.14);
      color:rgba(255,255,255,.92);
      font-weight:650;
      font-size:13px;
      line-height:1.2;
      text-shadow: 0 2px 10px rgba(0,0,0,.35);
      border:1px solid rgba(255,255,255,.18);
      backdrop-filter: blur(6px);
      user-select:none;
    }

    .bar{
      display:flex;
      align-items:center;
      gap:14px;
      padding:14px 16px;
      background:var(--bar);
      color:var(--barText);
    }

    .left{
      display:flex;
      align-items:center;
      gap:12px;
      flex:1 1 auto;
      min-width:0;
    }

    .controls{
      display:flex;
      gap:10px;
      align-items:center;
      flex:0 0 auto;
    }

    .btn{
      width:40px;
      height:40px;
      border-radius:999px;
      border:1.5px solid var(--btnBorder);
      background:var(--btnBg);
      display:flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
      user-select:none;
      transition: transform .06s ease, filter .15s ease;
    }
    .btn:hover{ filter:brightness(.99); }
    .btn:active{ transform: translateY(1px); }
    .btn svg{ width:18px; height:18px; fill:var(--btnIcon); }

    .title{
      font-weight:700;
      font-size:15px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      min-width:0;
    }

    .right{
      flex:0 0 auto;
      display:flex;
      align-items:center;
      gap:10px;
    }

    input[type="range"]{
      width:280px;
      max-width:34vw;
      height:10px;
      -webkit-appearance:none;
      appearance:none;
      background:var(--sliderTrack);
      border-radius:999px;
      outline:none;
      cursor:pointer;
    }
    input[type="range"]::-webkit-slider-thumb{
      -webkit-appearance:none;
      appearance:none;
      width:18px;
      height:18px;
      border-radius:6px;
      background:var(--sliderThumb);
      border:1px solid rgba(58,50,38,.12);
      box-shadow: 0 4px 14px rgba(0,0,0,.10);
    }
    input[type="range"]::-moz-range-thumb{
      width:18px;
      height:18px;
      border-radius:6px;
      background:var(--sliderThumb);
      border:1px solid rgba(58,50,38,.12);
      box-shadow: 0 4px 14px rgba(0,0,0,.10);
    }

    details{
      border-top:1px solid rgba(80,60,20,.08);
      background:rgba(80,60,20,.02);
      padding:10px 14px 14px;
    }
    summary{
      cursor:pointer;
      user-select:none;
      list-style:none;
      display:flex;
      align-items:center;
      justify-content:space-between;
      font-weight:800;
      font-size:13px;
      color:rgba(58,50,38,.76);
    }
    summary::-webkit-details-marker{ display:none; }

    .panel{
      margin-top:12px;
      display:grid;
      gap:12px;
    }

    .badges{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      font-size:12px;
      color:rgba(58,50,38,.62);
      font-weight:700;
    }
    .badge{
      padding:6px 10px;
      border-radius:999px;
      background:rgba(58,50,38,.06);
      border:1px solid rgba(58,50,38,.08);
    }

    .grid{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap:10px;
    }
    @media (max-width:720px){ .grid{ grid-template-columns:1fr 1fr; } }
    @media (max-width:420px){ .grid{ grid-template-columns:1fr; } }

    label{
      font-size:12px;
      font-weight:800;
      color:rgba(58,50,38,.72);
      display:block;
      margin-bottom:6px;
    }

    input[type="text"], input[type="number"], textarea{
      width:100%;
      box-sizing:border-box;
      border-radius:12px;
      border:1px solid rgba(58,50,38,.16);
      background:#fff;
      padding:10px 10px;
      font-size:13px;
      outline:none;
      color:rgba(58,50,38,.92);
    }

    input[type="color"]{
      width:100%;
      height:38px;
      padding:4px;
      border-radius:12px;
      border:1px solid rgba(58,50,38,.16);
      background:#fff;
      cursor:pointer;
    }

    textarea{ min-height: 92px; resize: vertical; }

    .row{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
    }

    .miniBtn{
      border-radius:12px;
      border:1px solid rgba(58,50,38,.16);
      background:#fff;
      padding:10px 12px;
      cursor:pointer;
      font-weight:900;
      font-size:13px;
      color:rgba(58,50,38,.92);
    }
    .miniBtn:active{ transform: translateY(1px); }

    .hint{
      font-size:12px;
      color:rgba(58,50,38,.60);
      line-height:1.35;
    }

    .hidden{ display:none !important; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="player">

      <div class="media">
        <img id="gifImg" alt="GIF" />
        <canvas id="freezeCanvas"></canvas>

        <div class="stamp">
          <div id="stampDate"></div>
          <div id="stampTime"></div>
        </div>
      </div>

      <div class="bar">
        <div class="left">
          <div class="controls">
            <button class="btn" id="shuffleBtn" title="Shuffle">
              <svg viewBox="0 0 24 24"><path d="M17 3h4v4h-2V6.41l-4.29 4.3-1.42-1.42L17.59 5H17V3zM3 7h4.59l3 3-1.42 1.42L6.76 9H3V7zm0 10h3.76l2.41-2.41 1.42 1.42-3 2.99H3v-2zm18-2v4h-4v-2h.59l-4.88-4.88 1.42-1.42L18.59 17H19v-2h2z"/></svg>
            </button>

            <button class="btn" id="prevBtn" title="Previous">
              <svg viewBox="0 0 24 24"><path d="M6 6h2v12H6V6zm3.5 6 10 6V6l-10 6z"/></svg>
            </button>

            <button class="btn" id="playBtn" title="Play/Pause">
              <svg id="pauseIcon" viewBox="0 0 24 24"><path d="M6 5h4v14H6V5zm8 0h4v14h-4V5z"/></svg>
              <svg id="playIcon" class="hidden" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
            </button>

            <button class="btn" id="nextBtn" title="Next">
              <svg viewBox="0 0 24 24"><path d="M16 6h2v12h-2V6zM5 18l10-6L5 6v12z"/></svg>
            </button>
          </div>

          <div class="title" id="trackTitle">GIF Player</div>
        </div>

        <div class="right">
          <input id="progress" type="range" min="0" max="1000" value="0" />
        </div>
      </div>

      <details>
        <summary>
          <span>Customize</span>
          <span class="hint">colors • gifs • upload</span>
        </summary>

        <div class="panel">
          <div class="badges">
            <span class="badge" id="countBadge">1 / 1</span>
            <span class="badge" id="modeBadge">Playing</span>
          </div>

          <div class="grid">
            <div><label>Page background</label><input type="color" id="cPage" value="#ffffff" /></div>
            <div><label>Card background</label><input type="color" id="cCard" value="#fffdf7" /></div>
            <div><label>Media background</label><input type="color" id="cMedia" value="#f4efe6" /></div>

            <div><label>Bar</label><input type="color" id="cBar" value="#e7ddcf" /></div>
            <div><label>Bar text</label><input type="color" id="cBarText" value="#3a3226" /></div>
            <div><label>Buttons (icon)</label><input type="color" id="cBtnIcon" value="#3a3226" /></div>

            <div><label>Buttons (background)</label><input type="color" id="cBtnBg" value="#ffffff" /></div>
            <div><label>Buttons (border)</label><input type="color" id="cBtnBorder" value="#d7cdbc" /></div>
            <div><label>Slider track</label><input type="color" id="cSliderTrack" value="#d8cfbf" /></div>

            <div><label>Slider thumb</label><input type="color" id="cSliderThumb" value="#ffffff" /></div>
            <div><label>Auto-advance (seconds)</label><input type="number" id="intervalSec" min="2" max="300" step="1" value="12" /></div>
          </div>

          <div class="grid">
            <div style="grid-column: span 2;">
              <label>Add GIF by URL</label>
              <input type="text" id="gifUrlInput" placeholder="https://.../file.gif" />
              <div class="row" style="margin-top:8px;">
                <button class="miniBtn" id="addGifUrlBtn" type="button">Add URL</button>
                <button class="miniBtn" id="removeCurrentBtn" type="button">Remove current</button>
              </div>
              <div class="hint">URLs can be blocked by some hosts. Upload is the most reliable.</div>
            </div>

            <div>
              <label>Upload GIF file</label>
              <input type="file" id="gifFileInput" accept="image/gif" />
              <div class="row" style="margin-top:8px;">
                <button class="miniBtn" id="addGifFileBtn" type="button">Add file</button>
              </div>
              <div class="hint" id="uploadHint">Saved locally if small enough.</div>
            </div>
          </div>

          <div>
            <label>GIF list (one per line)</label>
            <textarea id="gifListBox" spellcheck="false"></textarea>
            <div class="row" style="margin-top:8px;">
              <button class="miniBtn" id="applyListBtn" type="button">Apply list</button>
              <button class="miniBtn" id="clearUploadsBtn" type="button">Clear uploaded</button>
            </div>
            <div class="hint">This widget is isolated per GitHub Pages path + per browser profile.</div>
          </div>
        </div>
      </details>

    </div>
  </div>

<script>
  const DEFAULT_GIF_PATH = "./default.gif";   // default in your repo
  const DEFAULT_TITLE = "GIF Player";

  const STORAGE_KEY = "gif_player_widget_v9:" + location.pathname;

  // ~5MB typical limit; keep a safer cap for the whole widget
  const MAX_DATAURL_BYTES = 2.8 * 1024 * 1024; // ~2.8MB for a single uploaded gif
  const uploadHint = document.getElementById("uploadHint");

  function $(s){ return document.querySelector(s); }
  const clamp = (n,a,b) => Math.max(a, Math.min(b,n));

  let state = {
    gifs: [
      { title: DEFAULT_TITLE, type: "path", value: DEFAULT_GIF_PATH }
    ],
    index: 0,
    playing: true,
    shuffle: false,
    intervalSec: 12,
    colors: {
      page:"#ffffff",
      card:"#fffdf7",
      media:"#f4efe6",
      bar:"#e7ddcf",
      barText:"#3a3226",
      btnBg:"rgba(255,255,255,.65)",
      btnBorder:"rgba(58,50,38,.18)",
      btnIcon:"#3a3226",
      sliderTrack:"rgba(58,50,38,.16)",
      sliderThumb:"#ffffff"
    }
  };

  try{
    const raw = localStorage.getItem(STORAGE_KEY);
    if(raw){
      const saved = JSON.parse(raw);
      if(saved && typeof saved === "object"){
        state = {
          ...state,
          ...saved,
          colors: { ...state.colors, ...(saved.colors || {}) }
        };
      }
    }
  }catch(_){}

  function save(){
    try{ localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); }
    catch(e){
      // If storage is full, still work live; just can’t persist large uploads.
    }
  }

  const gifImg = $("#gifImg");
  const canvas = $("#freezeCanvas");
  const ctx = canvas.getContext("2d");

  const playIcon = $("#playIcon");
  const pauseIcon = $("#pauseIcon");
  const modeBadge = $("#modeBadge");
  const countBadge = $("#countBadge");
  const titleEl = $("#trackTitle");
  const progress = $("#progress");

  const gifUrlInput = $("#gifUrlInput");
  const gifFileInput = $("#gifFileInput");
  const gifListBox = $("#gifListBox");
  const intervalSecEl = $("#intervalSec");

  // color inputs
  const cPage = $("#cPage");
  const cCard = $("#cCard");
  const cMedia = $("#cMedia");
  const cBar = $("#cBar");
  const cBarText = $("#cBarText");
  const cBtnBg = $("#cBtnBg");
  const cBtnBorder = $("#cBtnBorder");
  const cBtnIcon = $("#cBtnIcon");
  const cSliderTrack = $("#cSliderTrack");
  const cSliderThumb = $("#cSliderThumb");

  function applyColors(){
    document.documentElement.style.setProperty("--page", state.colors.page);
    document.documentElement.style.setProperty("--card", state.colors.card);
    document.documentElement.style.setProperty("--media", state.colors.media);
    document.documentElement.style.setProperty("--bar", state.colors.bar);
    document.documentElement.style.setProperty("--barText", state.colors.barText);

    // For these we set variables used in CSS
    document.documentElement.style.setProperty("--btnBg", state.colors.btnBg);
    document.documentElement.style.setProperty("--btnBorder", state.colors.btnBorder);
    document.documentElement.style.setProperty("--btnIcon", state.colors.btnIcon);

    document.documentElement.style.setProperty("--sliderTrack", state.colors.sliderTrack);
    document.documentElement.style.setProperty("--sliderThumb", state.colors.sliderThumb);

    cPage.value = state.colors.page;
    cCard.value = state.colors.card;
    cMedia.value = state.colors.media;
    cBar.value = state.colors.bar;
    cBarText.value = state.colors.barText;

    // These are "colors", but in CSS we used rgba defaults.
    // We'll store them as hex when user changes them.
    cBtnIcon.value = state.colors.btnIcon;
    cSliderThumb.value = state.colors.sliderThumb;

    intervalSecEl.value = String(state.intervalSec);
  }

  function setPlayUI(){
    if(state.playing){
      playIcon.classList.add("hidden");
      pauseIcon.classList.remove("hidden");
      modeBadge.textContent = "Playing";
    }else{
      pauseIcon.classList.add("hidden");
      playIcon.classList.remove("hidden");
      modeBadge.textContent = "Paused";
    }
  }

  function updateBadges(){
    const total = state.gifs.length;
    const idx = total ? (state.index + 1) : 0;
    countBadge.textContent = `${idx} / ${total}`;
  }

  function unfreeze(){
    canvas.style.display = "none";
    gifImg.style.display = "block";
  }

  function freezeIfPossible(){
    const w = gifImg.naturalWidth || 0;
    const h = gifImg.naturalHeight || 0;
    if(!w || !h) return false;

    const rect = gifImg.getBoundingClientRect();
    canvas.width = Math.max(1, Math.round(rect.width));
    canvas.height = Math.max(1, Math.round(rect.height));
    try{ ctx.drawImage(gifImg, 0, 0, canvas.width, canvas.height); }
    catch(_){ return false; }

    gifImg.style.display = "none";
    canvas.style.display = "block";
    return true;
  }

  function cacheBust(url){
    const u = String(url);
    const sep = u.includes("?") ? "&" : "?";
    return u + sep + "v=" + Date.now().toString(36);
  }

  async function resolveSrc(item){
    if(item.type === "path" || item.type === "url"){
      return item.value;
    }
    if(item.type === "dataurl"){
      return item.value;
    }
    return "";
  }

  async function showCurrent({restart=true} = {}){
    if(!state.gifs.length){
      titleEl.textContent = "No GIFs";
      gifImg.removeAttribute("src");
      gifListBox.value = "";
      updateBadges();
      save();
      return;
    }

    state.index = clamp(state.index, 0, state.gifs.length - 1);
    const cur = state.gifs[state.index];

    titleEl.textContent = cur.title || DEFAULT_TITLE;
    unfreeze();

    let src = await resolveSrc(cur);
    if(!src) src = DEFAULT_GIF_PATH;

    gifImg.src = restart ? cacheBust(src) : src;

    gifListBox.value = state.gifs.map(g => {
      if(g.type === "dataurl") return "dataurl:(uploaded)";
      return g.value;
    }).join("\n");

    updateBadges();
    setPlayUI();
    save();
  }

  function nextIndex(){
    const total = state.gifs.length;
    if(total <= 1) return state.index;
    if(state.shuffle){
      let n = state.index;
      for(let t=0;t<12 && n===state.index;t++) n = Math.floor(Math.random()*total);
      return n === state.index ? (state.index+1)%total : n;
    }
    return (state.index + 1) % total;
  }
  function prevIndex(){
    const total = state.gifs.length;
    if(total <= 1) return state.index;
    if(state.shuffle){
      let n = state.index;
      for(let t=0;t<12 && n===state.index;t++) n = Math.floor(Math.random()*total);
      return n === state.index ? (state.index-1+total)%total : n;
    }
    return (state.index - 1 + total) % total;
  }

  let tickTimer=null, progTimer=null, progStart=0;

  function stopTimers(){
    if(tickTimer) clearInterval(tickTimer);
    if(progTimer) clearInterval(progTimer);
    tickTimer=null; progTimer=null;
    progress.value="0";
  }

  function startTimers(){
    stopTimers();
    if(!state.playing) return;
    const ms = state.intervalSec * 1000;
    progStart = Date.now();

    tickTimer = setInterval(() => {
      state.index = nextIndex();
      showCurrent({restart:true});
      progStart = Date.now();
    }, ms);

    progTimer = setInterval(() => {
      const ms = state.intervalSec * 1000;
      const pct = clamp((Date.now()-progStart)/ms, 0, 1);
      progress.value = String(Math.round(pct*1000));
    }, 80);
  }

  function play(){
    state.playing = true;
    unfreeze();
    setPlayUI();
    startTimers();
    showCurrent({restart:true});
  }

  function pause(){
    state.playing = false;
    stopTimers();
    setPlayUI();
    freezeIfPossible();
    save();
  }

  // Buttons
  $("#shuffleBtn").addEventListener("click", () => {
    state.shuffle = !state.shuffle;
    $("#shuffleBtn").style.opacity = state.shuffle ? "1" : ".72";
    save();
  });
  $("#prevBtn").addEventListener("click", () => {
    state.index = prevIndex();
    showCurrent({restart:true});
    if(state.playing){ progStart = Date.now(); progress.value="0"; }
  });
  $("#nextBtn").addEventListener("click", () => {
    state.index = nextIndex();
    showCurrent({restart:true});
    if(state.playing){ progStart = Date.now(); progress.value="0"; }
  });
  $("#playBtn").addEventListener("click", () => {
    state.playing ? pause() : play();
  });

  progress.addEventListener("input", () => {
    if(!state.playing) return;
    const pct = clamp(parseInt(progress.value,10)/1000, 0, 1);
    const ms = state.intervalSec * 1000;
    progStart = Date.now() - Math.round(pct*ms);
  });

  intervalSecEl.addEventListener("change", () => {
    const v = clamp(parseInt(intervalSecEl.value || "12", 10), 2, 300);
    state.intervalSec = v;
    save();
    if(state.playing) startTimers();
  });

  // Colors
  function wireColor(el, key){
    el.addEventListener("input", () => {
      state.colors[key] = el.value;
      applyColors();
      save();
    });
  }
  wireColor(cPage, "page");
  wireColor(cCard, "card");
  wireColor(cMedia, "media");
  wireColor(cBar, "bar");
  wireColor(cBarText, "barText");
  wireColor(cBtnIcon, "btnIcon");
  wireColor(cSliderThumb, "sliderThumb");

  // These are better stored as rgba-ish via hex, so we map them:
  cBtnBg.addEventListener("input", () => {
    state.colors.btnBg = cBtnBg.value;
    document.documentElement.style.setProperty("--btnBg", state.colors.btnBg);
    save();
  });
  cBtnBorder.addEventListener("input", () => {
    state.colors.btnBorder = cBtnBorder.value;
    document.documentElement.style.setProperty("--btnBorder", state.colors.btnBorder);
    save();
  });
  cSliderTrack.addEventListener("input", () => {
    state.colors.sliderTrack = cSliderTrack.value;
    document.documentElement.style.setProperty("--sliderTrack", state.colors.sliderTrack);
    save();
  });

  // Add URL
  $("#addGifUrlBtn").addEventListener("click", () => {
    const url = (gifUrlInput.value || "").trim();
    if(!url) return;
    state.gifs.push({ title: `GIF ${state.gifs.length+1}`, type:"url", value:url });
    state.index = state.gifs.length - 1;
    gifUrlInput.value = "";
    save();
    showCurrent({restart:true});
  });

  // Upload file => Data URL
  async function fileToDataURL(file){
    return new Promise((resolve, reject) => {
      const fr = new FileReader();
      fr.onload = () => resolve(fr.result);
      fr.onerror = () => reject(fr.error);
      fr.readAsDataURL(file);
    });
  }

  $("#addGifFileBtn").addEventListener("click", async () => {
    const file = gifFileInput.files && gifFileInput.files[0];
    if(!file) return;

    // Always show immediately via object URL (works even if too big to store)
    const tempUrl = URL.createObjectURL(file);
    state.gifs.push({ title: file.name || `Upload ${state.gifs.length+1}`, type:"url", value: tempUrl });
    state.index = state.gifs.length - 1;
    showCurrent({restart:true});

    // Try to persist as Data URL if small enough
    try{
      const dataUrl = await fileToDataURL(file);
      const approxBytes = Math.floor((dataUrl.length * 3) / 4); // base64 estimate
      if(approxBytes <= MAX_DATAURL_BYTES){
        // replace the temp object URL entry with a data url entry
        state.gifs[state.index] = { title: file.name || `Upload ${state.gifs.length}`, type:"dataurl", value: dataUrl };
        save();
        uploadHint.textContent = "Saved locally ✔";
      }else{
        uploadHint.textContent = "Too large to save — will work this session only.";
      }
    }catch(_){
      uploadHint.textContent = "Couldn’t save — will work this session only.";
    } finally {
      gifFileInput.value = "";
    }
  });

  // Remove current
  $("#removeCurrentBtn").addEventListener("click", () => {
    if(!state.gifs.length) return;
    state.gifs.splice(state.index, 1);
    state.index = clamp(state.index, 0, Math.max(0, state.gifs.length - 1));
    if(!state.gifs.length){
      state.gifs = [{ title: DEFAULT_TITLE, type:"path", value: DEFAULT_GIF_PATH }];
      state.index = 0;
    }
    save();
    showCurrent({restart:true});
  });

  // Apply list (URLs/paths only; dataurl placeholders stay)
  $("#applyListBtn").addEventListener("click", () => {
    const lines = (gifListBox.value || "")
      .split("\n").map(s => s.trim()).filter(Boolean);

    if(!lines.length){
      state.gifs = [{ title: DEFAULT_TITLE, type:"path", value: DEFAULT_GIF_PATH }];
      state.index = 0;
      save();
      showCurrent({restart:true});
      return;
    }

    state.gifs = lines.map((line, i) => {
      const isUrl = /^https?:\/\//i.test(line) || line.startsWith("blob:");
      return { title: `GIF ${i+1}`, type: isUrl ? "url" : "path", value: line };
    });

    state.index = 0;
    save();
    showCurrent({restart:true});
  });

  // Clear uploaded (remove dataurl + blob entries)
  $("#clearUploadsBtn").addEventListener("click", () => {
    state.gifs = state.gifs.filter(g => g.type !== "dataurl" && !String(g.value||"").startsWith("blob:"));
    if(!state.gifs.length){
      state.gifs = [{ title: DEFAULT_TITLE, type:"path", value: DEFAULT_GIF_PATH }];
      state.index = 0;
    } else {
      state.index = clamp(state.index, 0, state.gifs.length - 1);
    }
    uploadHint.textContent = "Cleared uploaded ✔";
    save();
    showCurrent({restart:true});
  });

  // Timestamp
  function formatStamp(d){
    $("#stampDate").textContent = d.toLocaleDateString(undefined, { weekday:"long", day:"numeric", month:"long", year:"numeric" });
    $("#stampTime").textContent = d.toLocaleTimeString(undefined, { hour:"2-digit", minute:"2-digit" });
  }
  formatStamp(new Date());
  setInterval(() => formatStamp(new Date()), 30*1000);

  // Init
  applyColors();
  $("#shuffleBtn").style.opacity = state.shuffle ? "1" : ".72";
  setPlayUI();
  updateBadges();
  showCurrent({restart:true});
  if(state.playing) startTimers();
</script>
</body>
</html>
