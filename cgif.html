<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Notion GIF Player Widget</title>

  <style>
    /* Pastel defaults (you can change everything in Customize) */
    :root{
      --page:#fbfaf6;
      --card:#ffffff;
      --bar:#6bb7b7;          /* teal pastel like screenshot */
      --barText:#ffffff;
      --text:#2b2b35;
      --muted:rgba(255,255,255,.85);
      --iconBg:rgba(255,255,255,.20);
      --iconBd:rgba(255,255,255,.55);
      --progressTrack:rgba(255,255,255,.42);
      --progressFill:#ffffff;

      --radius:22px;
      --shadow: 0 18px 60px rgba(30, 40, 45, .12);
      --stroke: rgba(0,0,0,.06);
    }

    html, body { height: 100%; }
    body{
      margin:0;
      display:flex;
      justify-content:center;
      align-items:flex-start;
      padding:18px;
      box-sizing:border-box;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      background: var(--page);
      color: var(--text);
    }

    /* Small-ish embed friendly */
    .wrap{
      width: min(860px, 92vw); /* will shrink nicely inside Notion columns */
    }

    .player{
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
      border: 1px solid var(--stroke);
      background: var(--card);
    }

    /* Top media area (rounded like screenshot) */
    .media{
      position:relative;
      background: #f2f2f2;
      aspect-ratio: 16 / 9;
      width:100%;
      overflow:hidden;
    }
    .media img, .media canvas{
      width:100%;
      height:100%;
      object-fit:cover;
      display:block;
    }
    .media canvas{ display:none; }

    /* timestamp overlay bottom-left */
    .stamp{
      position:absolute;
      left:16px;
      bottom:14px;
      color: rgba(255,255,255,.92);
      font-size: 14px;
      font-weight: 650;
      text-shadow: 0 2px 10px rgba(0,0,0,.35);
      letter-spacing:.2px;
      user-select:none;
      line-height:1.2;
      background: rgba(0,0,0,.14);
      padding: 8px 10px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.18);
      backdrop-filter: blur(6px);
    }

    /* Bottom bar */
    .bar{
      background: var(--bar);
      color: var(--barText);
      padding: 14px 16px;
      display:flex;
      align-items:center;
      gap: 14px;
    }

    .left{
      display:flex;
      align-items:center;
      gap:10px;
      min-width: 0;
      flex: 1 1 auto;
    }

    .controls{
      display:flex;
      gap:10px;
      align-items:center;
      flex: 0 0 auto;
    }

    .btn{
      width: 40px;
      height: 40px;
      border-radius: 999px;
      border: 2px solid var(--iconBd);
      background: var(--iconBg);
      color: var(--barText);
      display:inline-flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
      user-select:none;
      transition: transform .06s ease, filter .15s ease;
    }
    .btn:hover{ filter: brightness(1.02); }
    .btn:active{ transform: translateY(1px); }

    .btn svg{ width:18px; height:18px; fill: currentColor; }

    .track{
      min-width: 0;
      flex: 1 1 auto;
      display:flex;
      align-items:center;
      gap: 10px;
    }
    .trackTitle{
      font-size: 15px;
      font-weight: 650;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      opacity:.96;
    }

    /* Progress slider (right side like screenshot) */
    .right{
      flex: 0 0 auto;
      display:flex;
      align-items:center;
      gap:10px;
    }

    .slider{
      width: 280px;
      max-width: 34vw;
      height: 10px;
      -webkit-appearance: none;
      appearance: none;
      background: var(--progressTrack);
      border-radius: 999px;
      outline:none;
      cursor:pointer;
    }
    .slider::-webkit-slider-thumb{
      -webkit-appearance:none;
      appearance:none;
      width: 18px;
      height: 18px;
      border-radius: 6px;
      background: var(--progressFill);
      border: 2px solid rgba(0,0,0,.06);
      box-shadow: 0 4px 14px rgba(0,0,0,.15);
    }
    .slider::-moz-range-thumb{
      width: 18px;
      height: 18px;
      border-radius: 6px;
      background: var(--progressFill);
      border: 2px solid rgba(0,0,0,.06);
      box-shadow: 0 4px 14px rgba(0,0,0,.15);
    }

    /* Customize panel */
    details.customize{
      border-top: 1px solid rgba(0,0,0,.06);
      background: rgba(0,0,0,.02);
      padding: 10px 14px 14px;
    }
    summary{
      cursor:pointer;
      user-select:none;
      list-style:none;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      color: rgba(0,0,0,.65);
      font-weight: 650;
      font-size: 13px;
    }
    summary::-webkit-details-marker{ display:none; }

    .panel{
      margin-top: 12px;
      display:grid;
      gap: 12px;
    }

    .grid{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 10px;
    }
    @media (max-width: 720px){
      .grid{ grid-template-columns: 1fr 1fr; }
      .slider{ width: 180px; }
    }
    @media (max-width: 420px){
      .grid{ grid-template-columns: 1fr; }
    }

    .field{
      display:flex;
      flex-direction:column;
      gap:6px;
      min-width:0;
    }
    label{
      font-size: 12px;
      color: rgba(0,0,0,.6);
      font-weight: 650;
    }
    input[type="color"]{
      height: 38px;
      border-radius: 12px;
      border: 1px solid rgba(0,0,0,.10);
      background: #fff;
      padding: 4px;
      cursor:pointer;
    }
    input[type="text"], textarea, input[type="number"]{
      border-radius: 12px;
      border: 1px solid rgba(0,0,0,.10);
      background: #fff;
      padding: 10px 10px;
      font-size: 13px;
      outline:none;
      width:100%;
      box-sizing:border-box;
    }
    textarea{ min-height: 92px; resize: vertical; }

    .rowBtns{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
    }
    .miniBtn{
      border-radius: 12px;
      border: 1px solid rgba(0,0,0,.12);
      background: #fff;
      padding: 10px 12px;
      cursor:pointer;
      font-weight: 700;
      font-size: 13px;
    }
    .hint{
      font-size: 12px;
      color: rgba(0,0,0,.55);
      line-height: 1.35;
    }

    .statusLine{
      font-size: 12px;
      color: rgba(0,0,0,.55);
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
    }
    .badge{
      display:inline-flex;
      align-items:center;
      gap:6px;
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(0,0,0,.05);
      border: 1px solid rgba(0,0,0,.06);
      font-weight: 650;
    }

    .hidden { display:none !important; }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="player" id="player">
      <div class="media">
        <img id="gifImg" alt="GIF" />
        <canvas id="freezeCanvas"></canvas>

        <div class="stamp" id="stamp">
          <div id="stampDate">Wednesday, 4 February 2026</div>
          <div id="stampTime">06:59</div>
        </div>
      </div>

      <div class="bar">
        <div class="left">
          <div class="controls">
            <button class="btn" id="shuffleBtn" title="Shuffle">
              <!-- shuffle icon -->
              <svg viewBox="0 0 24 24" aria-hidden="true">
                <path d="M17 3h4v4h-2V6.41l-4.29 4.3-1.42-1.42L17.59 5H17V3zM3 7h4.59l3 3-1.42 1.42L6.76 9H3V7zm0 10h3.76l2.41-2.41 1.42 1.42-3 2.99H3v-2zm18-2v4h-4v-2h.59l-4.88-4.88 1.42-1.42L18.59 17H19v-2h2z"/>
              </svg>
            </button>

            <button class="btn" id="prevBtn" title="Previous">
              <!-- prev -->
              <svg viewBox="0 0 24 24" aria-hidden="true">
                <path d="M6 6h2v12H6V6zm3.5 6 10 6V6l-10 6z"/>
              </svg>
            </button>

            <button class="btn" id="playBtn" title="Play/Pause">
              <!-- play (will toggle) -->
              <svg id="playIcon" viewBox="0 0 24 24" aria-hidden="true">
                <path d="M8 5v14l11-7z"/>
              </svg>
              <svg id="pauseIcon" class="hidden" viewBox="0 0 24 24" aria-hidden="true">
                <path d="M6 5h4v14H6V5zm8 0h4v14h-4V5z"/>
              </svg>
            </button>

            <button class="btn" id="nextBtn" title="Next">
              <!-- next -->
              <svg viewBox="0 0 24 24" aria-hidden="true">
                <path d="M16 6h2v12h-2V6zM5 18l10-6L5 6v12z"/>
              </svg>
            </button>
          </div>

          <div class="track">
          </div>
        </div>

        <div class="right">
          <input id="progress" class="slider" type="range" min="0" max="1000" value="0" />
        </div>
      </div>

      <details class="customize">
        <summary>
          <span>Customize</span>
        </summary>

        <div class="panel">
          <div class="statusLine">
            <span class="badge" id="countBadge">1 / 1</span>
            <span class="badge" id="modeBadge">Paused</span>
          </div>

          <div class="grid">
            <div class="field">
              <label>Page background</label>
              <input type="color" id="cPage" value="#fbfaf6" />
            </div>
            <div class="field">
              <label>Card background</label>
              <input type="color" id="cCard" value="#ffffff" />
            </div>
            <div class="field">
              <label>Bar color</label>
              <input type="color" id="cBar" value="#6bb7b7" />
            </div>
            <div class="field">
              <label>Bar text</label>
              <input type="color" id="cBarText" value="#ffffff" />
            </div>
            <div class="field">
              <label>Progress track</label>
              <input type="color" id="cProgTrack" value="#d7f0f0" />
            </div>
            <div class="field">
              <label>Progress thumb</label>
              <input type="color" id="cProgFill" value="#ffffff" />
            </div>
          </div>

          <div class="grid">
            <div class="field">
              <label>Auto-advance (seconds)</label>
              <input type="number" id="intervalSec" min="2" max="300" step="1" value="12" />
            </div>

            <div class="field" style="grid-column: span 2;">
              <label>Add a GIF URL</label>
              <input type="text" id="gifUrlInput" placeholder="https://.../any.gif" />
              <div class="rowBtns" style="margin-top:8px;">
                <button class="miniBtn" id="addGifBtn" type="button">Add</button>
                <button class="miniBtn" id="removeCurrentBtn" type="button">Remove current</button>
                <button class="miniBtn" id="resetBtn" type="button">Reset to single default</button>
              </div>
              <div class="hint">
              </div>
            </div>
          </div>

          <div class="field">
            <label>GIF list (one URL per line)</label>
            <textarea id="gifListBox" spellcheck="false"></textarea>
            <div class="rowBtns">
              <button class="miniBtn" id="applyListBtn" type="button">Apply list</button>
            </div>
          </div>
        </div>
      </details>
    </div>
  </div>

  <script>
    /**
     * Notion GIF Player Widget (single HTML)
     * - Layout inspired by your screenshot: big media + bottom player bar + progress.
     * - Default GIF: the one you provided.
     * - Per-user & per-embed persistence: localStorage scoped to this page path.
     * - Pause: "best effort" — we try to freeze the current frame by drawing to canvas.
     *   For cross-origin GIFs, we fetch->blob->objectURL to make the canvas drawable.
     */

    const DEFAULT_GIFS = [
      {
        title: "It started Raining…",
        url: "https://media3.giphy.com/media/v1.Y2lkPTc5MGI3NjExMGgzaXVjaXR6YmxiZ280M3l3ZTlrdTE4bWxtMHF4cGgyeHg5MzFsdCZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/Dsvz9D6FBdmk8/giphy.gif"
      }
    ];

    const $ = (s) => document.querySelector(s);
    const clamp = (n, a, b) => Math.max(a, Math.min(b, n));

    // Make embeds independent by scoping storage to the page path
    const STORAGE_KEY = "notion_gif_player_v3:" + location.pathname;

    function loadState(){
      try{
        const raw = localStorage.getItem(STORAGE_KEY);
        return raw ? JSON.parse(raw) : null;
      }catch(_){ return null; }
    }
    function saveState(){
      try{ localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); }catch(_){}
    }

    // State
    const state = {
      gifs: DEFAULT_GIFS.slice(),
      index: 0,
      playing: false,
      shuffle: false,
      intervalSec: 12,
      colors: {
        page: "#fbfaf6",
        card: "#ffffff",
        bar:  "#6bb7b7",
        barText: "#ffffff",
        progTrack: "#d7f0f0",
        progFill: "#ffffff"
      }
    };

    // Restore
    const persisted = loadState();
    if(persisted){
      if(Array.isArray(persisted.gifs) && persisted.gifs.length){
        state.gifs = persisted.gifs.map((g, i) => {
          if(typeof g === "string") return { title: `GIF ${i+1}`, url: g };
          if(g && typeof g.url === "string") return { title: g.title || `GIF ${i+1}`, url: g.url };
          return null;
        }).filter(Boolean);
      }
      if(Number.isInteger(persisted.index)) state.index = clamp(persisted.index, 0, Math.max(0, state.gifs.length - 1));
      if(typeof persisted.playing === "boolean") state.playing = persisted.playing;
      if(typeof persisted.shuffle === "boolean") state.shuffle = persisted.shuffle;
      if(Number.isFinite(persisted.intervalSec)) state.intervalSec = clamp(persisted.intervalSec, 2, 300);
      if(persisted.colors && typeof persisted.colors === "object"){
        state.colors = { ...state.colors, ...persisted.colors };
      }
    }

    // UI
    const gifImg = $("#gifImg");
    const freezeCanvas = $("#freezeCanvas");
    const trackTitle = $("#trackTitle");
    const progress = $("#progress");

    const shuffleBtn = $("#shuffleBtn");
    const prevBtn = $("#prevBtn");
    const playBtn = $("#playBtn");
    const nextBtn = $("#nextBtn");
    const playIcon = $("#playIcon");
    const pauseIcon = $("#pauseIcon");

    const countBadge = $("#countBadge");
    const modeBadge = $("#modeBadge");
    const pauseSupportBadge = $("#pauseSupportBadge");

    const cPage = $("#cPage");
    const cCard = $("#cCard");
    const cBar = $("#cBar");
    const cBarText = $("#cBarText");
    const cProgTrack = $("#cProgTrack");
    const cProgFill = $("#cProgFill");

    const intervalSecInput = $("#intervalSec");
    const gifUrlInput = $("#gifUrlInput");
    const addGifBtn = $("#addGifBtn");
    const removeCurrentBtn = $("#removeCurrentBtn");
    const resetBtn = $("#resetBtn");
    const gifListBox = $("#gifListBox");
    const applyListBtn = $("#applyListBtn");

    // Keep object URLs so we can revoke them
    const objectUrlCache = new Map(); // originalUrl -> objectUrl

    function applyColors(){
      document.documentElement.style.setProperty("--page", state.colors.page);
      document.documentElement.style.setProperty("--card", state.colors.card);
      document.documentElement.style.setProperty("--bar", state.colors.bar);
      document.documentElement.style.setProperty("--barText", state.colors.barText);
      document.documentElement.style.setProperty("--progressTrack", state.colors.progTrack);
      document.documentElement.style.setProperty("--progressFill", state.colors.progFill);

      cPage.value = state.colors.page;
      cCard.value = state.colors.card;
      cBar.value = state.colors.bar;
      cBarText.value = state.colors.barText;
      cProgTrack.value = state.colors.progTrack;
      cProgFill.value = state.colors.progFill;
    }

    // A better pause strategy:
    // Try fetch->blob to allow drawing to canvas (avoids tainted canvas from cross-origin).
    // If fetch fails (CORS blocked), we still show the GIF normally, but pause freeze may not work.
    async function resolveGifSrc(url){
      const u = String(url || "").trim();
      if(!u) return { src: "", pauseLikely: false };

      if(objectUrlCache.has(u)){
        return { src: objectUrlCache.get(u), pauseLikely: true };
      }

      try{
        const resp = await fetch(u, { mode: "cors", cache: "force-cache" });
        if(!resp.ok) throw new Error("fetch failed: " + resp.status);
        const blob = await resp.blob();
        const objUrl = URL.createObjectURL(blob);
        objectUrlCache.set(u, objUrl);
        return { src: objUrl, pauseLikely: true };
      }catch(_){
        // Fallback to direct URL (still displays)
        return { src: u, pauseLikely: false };
      }
    }

    function updateBadges(pauseLikely){
      const total = state.gifs.length;
      const idx = total ? (state.index + 1) : 0;
      countBadge.textContent = `${idx} / ${total}`;
      modeBadge.textContent = state.playing ? "Playing" : "Paused";
      pauseSupportBadge.textContent = pauseLikely ? "";
    }

    function setPlayIcon(){
      if(state.playing){
        playIcon.classList.add("hidden");
        pauseIcon.classList.remove("hidden");
      }else{
        pauseIcon.classList.add("hidden");
        playIcon.classList.remove("hidden");
      }
    }

    function unfreeze(){
      freezeCanvas.style.display = "none";
      gifImg.style.display = "block";
    }

    function freeze(){
      // Draw current frame to canvas when possible
      const w = gifImg.naturalWidth || 0;
      const h = gifImg.naturalHeight || 0;
      if(!w || !h){
        // If not loaded, just hide img (gives a "paused" feel)
        gifImg.style.display = "none";
        freezeCanvas.style.display = "block";
        return;
      }

      const rect = gifImg.getBoundingClientRect();
      const cw = Math.max(1, Math.round(rect.width));
      const ch = Math.max(1, Math.round(rect.height));
      freezeCanvas.width = cw;
      freezeCanvas.height = ch;

      const ctx = freezeCanvas.getContext("2d");
      try{
        ctx.drawImage(gifImg, 0, 0, cw, ch);
        gifImg.style.display = "none";
        freezeCanvas.style.display = "block";
      }catch(_){
        // Canvas might be tainted if host blocks it — fallback:
        gifImg.style.display = "none";
        freezeCanvas.style.display = "block";
      }
    }

    function nextIndex(){
      const total = state.gifs.length;
      if(total <= 1) return state.index;

      if(state.shuffle){
        let n = state.index;
        for(let tries=0; tries<12 && n === state.index; tries++){
          n = Math.floor(Math.random() * total);
        }
        return (n === state.index) ? (state.index + 1) % total : n;
      }
      return (state.index + 1) % total;
    }

    function prevIndex(){
      const total = state.gifs.length;
      if(total <= 1) return state.index;

      if(state.shuffle){
        let n = state.index;
        for(let tries=0; tries<12 && n === state.index; tries++){
          n = Math.floor(Math.random() * total);
        }
        return (n === state.index) ? (state.index - 1 + total) % total : n;
      }
      return (state.index - 1 + total) % total;
    }

    let tickTimer = null;
    let progTimer = null;
    let progStart = 0;

    function stopTimers(){
      if(tickTimer) clearInterval(tickTimer);
      if(progTimer) clearInterval(progTimer);
      tickTimer = null;
      progTimer = null;
      progress.value = "0";
    }

    function startTimers(){
      stopTimers();
      if(!state.playing) return;

      const ms = state.intervalSec * 1000;
      progStart = Date.now();

      tickTimer = setInterval(() => {
        showGif(nextIndex(), { restart:true });
        progStart = Date.now();
      }, ms);

      progTimer = setInterval(() => {
        const elapsed = Date.now() - progStart;
        const pct = clamp(elapsed / ms, 0, 1);
        progress.value = String(Math.round(pct * 1000));
      }, 80);
    }

    async function showGif(index, { restart=false } = {}){
      const total = state.gifs.length;
      if(!total){
        trackTitle.textContent = "No GIFs";
        gifImg.removeAttribute("src");
        unfreeze();
        updateBadges(false);
        saveState();
        return;
      }

      state.index = clamp(index, 0, total - 1);
      const cur = state.gifs[state.index];
      trackTitle.textContent = cur.title || "GIF Player";

      unfreeze();

      // Try to get a drawable src
      const { src, pauseLikely } = await resolveGifSrc(cur.url);

      // If restart requested (resume / next while playing), re-create src by cache-busting for direct URLs.
      // For object URLs, restarting isn't necessary; setting src again is enough.
      if(restart && !objectUrlCache.has(cur.url)){
        const u = cur.url;
        const sep = u.includes("?") ? "&" : "?";
        gifImg.src = u + sep + "v=" + Date.now().toString(36);
      }else{
        gifImg.src = src;
      }

      gifListBox.value = state.gifs.map(g => g.url).join("\n");
      intervalSecInput.value = String(state.intervalSec);

      updateBadges(pauseLikely);
      setPlayIcon();
      saveState();
    }

    function play(){
      state.playing = true;
      setPlayIcon();
      unfreeze();
      showGif(state.index, { restart:true });
      startTimers();
      saveState();
    }

    function pause(){
      state.playing = false;
      setPlayIcon();
      stopTimers();
      freeze();
      updateBadges(true); // display-only; actual support depends on src
      saveState();
    }

    function togglePlay(){
      state.playing ? pause() : play();
    }

    // Customize: GIF list management
    function addGif(url){
      const cleaned = String(url || "").trim();
      if(!cleaned) return;
      state.gifs.push({ title: `GIF ${state.gifs.length + 1}`, url: cleaned });
      showGif(state.gifs.length - 1, { restart: state.playing });
      saveState();
    }

    function removeCurrent(){
      if(state.gifs.length === 0) return;
      state.gifs.splice(state.index, 1);
      state.index = clamp(state.index, 0, Math.max(0, state.gifs.length - 1));
      showGif(state.index, { restart: state.playing });
      saveState();
    }

    function applyList(){
      const lines = gifListBox.value.split("\n").map(s => s.trim()).filter(Boolean);
      if(lines.length === 0){
        state.gifs = [];
        state.index = 0;
        showGif(0);
        saveState();
        return;
      }
      state.gifs = lines.map((u, i) => ({ title: `GIF ${i+1}`, url: u }));
      state.index = clamp(state.index, 0, state.gifs.length - 1);
      showGif(state.index, { restart: state.playing });
      saveState();
    }

    function resetDefaults(){
      state.gifs = DEFAULT_GIFS.slice();
      state.index = 0;
      showGif(0, { restart: state.playing });
      saveState();
    }

    // Color wiring
    function wireColor(input, key){
      input.addEventListener("input", () => {
        state.colors[key] = input.value;
        applyColors();
        saveState();
      });
    }

    // Events
    shuffleBtn.addEventListener("click", () => {
      state.shuffle = !state.shuffle;
      // subtle feedback: dim icon background slightly when off
      shuffleBtn.style.opacity = state.shuffle ? "1" : ".72";
      saveState();
    });

    prevBtn.addEventListener("click", () => {
      showGif(prevIndex(), { restart: state.playing });
      if(state.playing){ progStart = Date.now(); progress.value = "0"; }
    });

    nextBtn.addEventListener("click", () => {
      showGif(nextIndex(), { restart: state.playing });
      if(state.playing){ progStart = Date.now(); progress.value = "0"; }
    });

    playBtn.addEventListener("click", togglePlay);

    // Let the slider act like "scrub" through the timer window
    progress.addEventListener("input", () => {
      if(!state.playing) return;
      // Set progressStart so the bar jumps to where user dragged
      const pct = clamp(parseInt(progress.value, 10) / 1000, 0, 1);
      const ms = state.intervalSec * 1000;
      progStart = Date.now() - Math.round(pct * ms);
    });

    intervalSecInput.addEventListener("change", () => {
      const v = clamp(parseInt(intervalSecInput.value || "12", 10), 2, 300);
      state.intervalSec = v;
      intervalSecInput.value = String(v);
      saveState();
      if(state.playing) startTimers();
    });

    addGifBtn.addEventListener("click", () => {
      addGif(gifUrlInput.value);
      gifUrlInput.value = "";
    });
    gifUrlInput.addEventListener("keydown", (e) => {
      if(e.key === "Enter"){
        e.preventDefault();
        addGif(gifUrlInput.value);
        gifUrlInput.value = "";
      }
    });

    removeCurrentBtn.addEventListener("click", removeCurrent);
    applyListBtn.addEventListener("click", applyList);
    resetBtn.addEventListener("click", resetDefaults);

    wireColor(cPage, "page");
    wireColor(cCard, "card");
    wireColor(cBar, "bar");
    wireColor(cBarText, "barText");
    wireColor(cProgTrack, "progTrack");
    wireColor(cProgFill, "progFill");

    // Timestamp: use the viewer's local time (keeps the vibe of the screenshot)
    function formatStamp(d){
      const day = d.toLocaleDateString(undefined, { weekday:"long", day:"numeric", month:"long", year:"numeric" });
      const time = d.toLocaleTimeString(undefined, { hour:"2-digit", minute:"2-digit" });
      $("#stampDate").textContent = day;
      $("#stampTime").textContent = time;
    }
    formatStamp(new Date());
    setInterval(() => formatStamp(new Date()), 30 * 1000);

    // Init
    function init(){
      applyColors();
      shuffleBtn.style.opacity = state.shuffle ? "1" : ".72";
      intervalSecInput.value = String(state.intervalSec);
      gifListBox.value = state.gifs.map(g => g.url).join("\n");
      setPlayIcon();
      showGif(state.index);
      if(state.playing) play();
      else pause();
    }

    init();

    // Cleanup object URLs on unload
    window.addEventListener("beforeunload", () => {
      for(const obj of objectUrlCache.values()){
        try{ URL.revokeObjectURL(obj); }catch(_){}
      }
    });
  </script>
</body>
</html>
